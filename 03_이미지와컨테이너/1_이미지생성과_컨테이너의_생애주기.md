
## 이미지 생성

이미지를 생성하는 방식은 2가지가 있다. 도커를 사용할 준비가 되었으니 이제 활용을 해보자

이미지와 관련된 자주쓰는 커멘드는 아래와 같다. 

| **명령어** | **설명** |
| --- | --- |
| **`docker images`** | 로컬 이미지 목록 확인. |
| **`docker pull`** | 도커 허브에서 이미지 다운로드. |
| **`docker push`** | 도커 허브로 이미지 업로드. |
| **`docker build`** | Dockerfile로 이미지 생성. |
| **`docker tag`** | 이미지 태그를 새로 추가. |
| **`docker rmi`** | 이미지 삭제. |
| **`docker save`** / **`docker load`** | 이미지를 파일로 저장/불러오기. |
| **`docker image prune`** | 사용되지 않는 이미지 삭제. |

### 기존 컨테이너를 이미지로 변환

첫 번째 방식은 컨테이너로 이미지를 만드는 방식이다. 이는 기존 컨테이너를 복제하거나 이동해야 할 때 사용한다

```powershell
docker commit "컨테이너_이름" "새로운_이미지_이름"
```

docker commit의 경우 간단한 명령어이지만 이는 이미지 생성 과정이 명시적이지 않아 유지보수가 어렵다는 단점이 있어 번거롭지만 도커 파일을 작성하여 이미지를 생성하는 것이 더 좋다. 

### 도커 스크립트로 이미지 생성

두번째 방식은 dockerfile 스크립트를 작성하여 이를 빌드해 이미지를 만드는 것이다. 이 스크립트안에는 토대가 될 이미지나 실행할 명령어 등을 작성하면 된다. 파일의 위치는 이미지 재료가 들어있는 폴더에 있으면 된다.(위치 무관)

```powershell
docker build -t "생성할_이미지_이름" "도커파일 경로"
```

도커 파일안에 들어가는 인스트럭션들을 아래와 같다

| **인스트럭션** | **설명** |
| --- | --- |
| **FROM** | 베이스 이미지 지정. Dockerfile은 항상 이 인스트럭션으로 시작해야 함. |
| **RUN** | 컨테이너 빌드 과정에서 명령어를 실행. |
| **CMD** | 컨테이너가 실행될 때 기본으로 실행될 명령어를 설정. |
| **ENTRYPOINT** | 컨테이너가 실행될 때 기본으로 실행될 명령어를 설정. CMD와 조합하여 유연하게 사용 가능. |
| **COPY** | 호스트 머신의 파일/디렉토리를 이미지에 복사. |
| **ADD** | COPY와 유사하지만, URL에서 파일을 다운로드하거나 압축 파일을 해제할 수 있음. |
| **WORKDIR** | 컨테이너 내부에서 작업 디렉토리를 설정. |
| **ENV** | 환경 변수를 설정. |
| **EXPOSE** | 컨테이너에서 사용할 네트워크 포트를 지정(단순 명시, 실제 포트 맵핑은 **`docker run -p`**로 설정). |
| **VOLUME** | 컨테이너에서 데이터를 저장할 디렉토리를 설정(호스트와 데이터 공유 가능). |
| **ARG** | 빌드 시점에 전달할 변수를 정의. |
| **LABEL** | 이미지에 메타데이터를 추가. |
| **USER** | 컨테이너 내에서 명령어를 실행할 사용자를 지정. |
| **ONBUILD** | 부모 이미지에서 후속 작업을 정의. |
| **SHELL** | RUN, CMD 또는 ENTRYPOINT에서 사용할 기본 셸을 지정. |

아래는 위 인스트럭션을 바탕으로 예시로 작성한 도커파일예시이다.

```tsx
#Python Flask 예시  

# Base image 설정 (Python 3.9)
FROM python:3.9-slim

# 작업 디렉토리 생성 및 설정
WORKDIR /app

# 의존성 파일 복사 및 설치
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# 애플리케이션 코드 복사
COPY app.py .

# 컨테이너 시작 시 실행할 명령어
CMD ["python", "app.py"]

###########################################################################

#Node.js 예시  

# Base image 설정
FROM node:14

# 작업 디렉토리 설정
WORKDIR /usr/src/app

# 의존성 복사 및 설치
COPY package*.json ./
RUN npm install

# 애플리케이션 복사
COPY . .

# 포트 노출
EXPOSE 3000

# 실행 명령어 설정
CMD ["node", "server.js"]

```

## 컨테이너 생애주기

이미지를 토대로 컨테이너를 생성, 실행하고 삭제해보자. 

앞서 도커를 사용하기 위한 도커 데스크톱을 설치했다면 도커엔진을 이용해 컨테이너를 실행시킬 수 있게 된다. 도케 데스크톱의 경우 도커 엔진을 자동으로 실행시키지만 도커 엔진 위에 컨테이너는 도커엔진이 한번 정지되면 모든 컨테이너는 정지 상태가 된다. 

이는 서비스의 심각한 마비를 뜻하기 때문에 서버에 문제가 생겨 재가동을 하는 경우에도 컨테이너가 자동 복구되도록 추가 프로그램을 작성해야한다. 

컨테이너는 도커 명령어를 바탕으로 실행된다. 

### 컨테이너 조작 관련 커멘드

1. 컨테이너 생성 및 실행
    
    ```powershell
    docker run [OPTIONS] <이미지 이름>
    ```
    
    **주요 옵션**
    
    | **옵션** | **설명** |
    | --- | --- |
    | **`-d`** | 컨테이너를 백그라운드에서 실행. |
    | **`--name <이름>`** | 컨테이너 이름을 지정. |
    | **`-p <호스트 포트>:<컨테이너 포트>`** | 호스트와 컨테이너 간 포트를 매핑. |
    | **`-v <호스트 경로>:<컨테이너 경로>`** | 호스트와 컨테이너 간 디렉터리를 공유. |
2. 실행중인 컨테이너 확인
    
    ```powershell
    docker ps -a #실행 중이지 않은 모든 컨테이너도 표시
    ```
    
3. 컨테이너 시작 및 재시작
    
    ```powershell
    docker start <컨테이너 ID 또는 이름>
    docker restart <컨테이너 ID 또는 이름>
    ```
    
4. 컨테이너 정지 및 종료
    
    ```powershell
    docker stop <컨테이너 ID 또는 이름>
    docker kill <컨테이너 ID 또는 이름> #컨테이너 강제 종료
    ```
    
5. 컨테이너 삭제
    
    ```powershell
    docker rm <컨테이너 ID 또는 이름>
    docker rm -f <컨테이너 ID 또는 이름> # 실행중이던 컨테이너 강제 삭제
    ```